# Raw Private Key Support - Implementation Guide

**Feature**: Support raw secp256k1 private keys as an alternative to BIP39 mnemonics

**Status**: Phase 1.5 - After KeyManager refactor completes

**Timeline**: ~2-3 days implementation + testing

---

## Table of Contents

1. [Overview](#overview)
2. [Why This Feature](#why-this-feature)
3. [Architecture](#architecture)
4. [Implementation Steps](#implementation-steps)
5. [File-by-File Changes](#file-by-file-changes)
6. [Testing Strategy](#testing-strategy)
7. [Migration Guide](#migration-guide)
8. [Validation Checklist](#validation-checklist)

---

## Overview

### What This Feature Adds

Currently, Igra signers derive keys from **BIP39 mnemonics** (24 words) using HD derivation paths.

This feature adds support for **raw secp256k1 private keys** (32 bytes) as an alternative key source.

### Use Cases

1. **Hardware Wallet Integration**: Import keys exported from Ledger/Trezor
2. **External Key Generation**: Use keys generated by other systems
3. **Simplified Setup**: Skip HD derivation for single-purpose keys
4. **Performance**: Eliminate derivation overhead (microseconds, but cleaner)
5. **Key Migration**: Import existing keys without mnemonic conversion

### Backwards Compatibility

âœ… **100% backwards compatible**
- Existing mnemonic-based configs work unchanged
- New raw key configs are opt-in
- Can mix both types in same deployment

---

## Why This Feature

### Current Flow (Mnemonic-Based)

```
BIP39 Mnemonic (24 words)
    â†“
BIP32 Derivation (m/45'/111111'/0'/0/0)
    â†“
secp256k1 Private Key (32 bytes)
    â†“
Signing Keypair
```

**Storage**: Mnemonic stored in KeyManager (200+ bytes as UTF-8 string)

### New Flow (Raw Private Key)

```
secp256k1 Private Key (32 bytes)
    â†“
Signing Keypair
```

**Storage**: Raw key stored in KeyManager (32 bytes)

### Benefits

| Aspect | Mnemonic | Raw Key |
|--------|----------|---------|
| **Storage** | ~200 bytes | 32 bytes |
| **Derivation** | Required | None |
| **Speed** | +1ms overhead | Direct |
| **Backup** | Human-readable | Binary (hex) |
| **External Import** | Requires conversion | Direct import |
| **HD Support** | Multiple keys from one seed | One key per secret |

---

## Architecture

### Key Type Enum

```rust
pub enum KeyType {
    HdMnemonic,      // Existing: BIP39 + derivation
    RawPrivateKey,   // New: Direct secp256k1 key
}
```

### Secret Storage

**Mnemonic-based**:
```
KeyManager SecretStore:
  igra.hd.mnemonic_signer_1 = "word1 word2 ... word24"
```

**Raw key-based**:
```
KeyManager SecretStore:
  igra.signer.private_key_signer_1 = [32 bytes]
```

### Configuration

```toml
[profiles.signer-1]
key_type = "raw_private_key"  # NEW field
derivation_path = ""           # Empty for raw keys
rpc_address = "127.0.0.1:8088"

[profiles.signer-2]
key_type = "hd_mnemonic"       # Existing (default)
derivation_path = "m/45'/111111'/0'/0/0"
rpc_address = "127.0.0.1:8089"
```

---

## Implementation Steps

### Phase 1: Foundation (Day 1)

1. Add `KeyType` enum to config types
2. Add `keypair_from_bytes()` helper function
3. Update `ProfileConfig` to include `key_type`
4. Add unit tests for key parsing

### Phase 2: Integration (Day 1-2)

5. Update PSKT signing to dispatch on key type
6. Update devnet-keygen to support raw key generation
7. Update KeyManager setup to validate key types
8. Add integration tests

### Phase 3: Documentation & Testing (Day 2-3)

9. Add examples for raw key usage
10. Test migration scenarios
11. Update operator documentation
12. Performance benchmarking

---

## File-by-File Changes

### Change 1: Add KeyType Enum

**File**: `igra-core/src/infrastructure/config/types.rs`

**Location**: Add after imports, before `ProfileConfig`

```rust
/// Type of cryptographic key material used by a signer
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum KeyType {
    /// BIP39 mnemonic with HD derivation path
    ///
    /// Stores 24-word mnemonic and derives keys using BIP32.
    /// Supports multiple keys from single seed.
    #[serde(alias = "mnemonic")]
    HdMnemonic,

    /// Raw secp256k1 private key (32 bytes)
    ///
    /// Direct private key without HD derivation.
    /// Use for hardware wallet imports or external keys.
    #[serde(alias = "raw", alias = "private_key")]
    RawPrivateKey,
}

impl Default for KeyType {
    fn default() -> Self {
        // Default to existing behavior (HD mnemonic)
        Self::HdMnemonic
    }
}

impl std::fmt::Display for KeyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::HdMnemonic => write!(f, "hd_mnemonic"),
            Self::RawPrivateKey => write!(f, "raw_private_key"),
        }
    }
}
```

**Update `ProfileConfig`**:

Find the existing `ProfileConfig` struct and add the `key_type` field:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProfileConfig {
    /// Profile name (e.g., "signer-1")
    pub name: String,

    /// Type of key material for this profile
    ///
    /// Defaults to HdMnemonic for backwards compatibility.
    #[serde(default)]
    pub key_type: KeyType,

    /// HD derivation path (only used when key_type = HdMnemonic)
    ///
    /// Example: "m/45'/111111'/0'/0/0"
    /// Ignored for RawPrivateKey.
    #[serde(default)]
    pub derivation_path: String,

    // ... existing fields (rpc_address, etc.)
}
```

---

### Change 2: Add Raw Key Helper Functions

**File**: `igra-core/src/foundation/hd.rs`

**Location**: Add after existing `derive_keypair_from_key_data()` function

```rust
/// Create signing keypair directly from raw secp256k1 private key
///
/// This bypasses HD derivation and creates a keypair directly from
/// a 32-byte private key. Used for hardware wallet imports and
/// externally-generated keys.
///
/// # Arguments
/// * `secret_key` - secp256k1 private key
///
/// # Returns
/// SigningKeypair with x-only public key (Schnorr)
pub fn derive_keypair_from_raw_key(
    secret_key: secp256k1::SecretKey,
) -> Result<SigningKeypair, ThresholdError> {
    let secp = secp256k1::Secp256k1::new();
    let public_key = secp256k1::PublicKey::from_secret_key(&secp, &secret_key);

    // Extract x-only pubkey for Schnorr signatures
    let (xonly_pubkey, _parity) = public_key.x_only_public_key();

    Ok(SigningKeypair {
        public_key: xonly_pubkey.serialize().to_vec(),
        secret_bytes: secret_key.secret_bytes(),
    })
}

/// Parse raw private key bytes into signing keypair
///
/// Validates that bytes represent a valid secp256k1 private key.
///
/// # Arguments
/// * `secret_bytes` - 32 bytes representing secp256k1 private key
///
/// # Returns
/// SigningKeypair or error if invalid
///
/// # Example
/// ```ignore
/// let key_bytes = hex::decode("deadbeef...")?;
/// let keypair = keypair_from_bytes(&key_bytes)?;
/// ```
pub fn keypair_from_bytes(
    secret_bytes: &[u8],
) -> Result<SigningKeypair, ThresholdError> {
    if secret_bytes.len() != 32 {
        return Err(ThresholdError::KeyOperationFailed {
            operation: "parse_private_key".to_string(),
            key_ref: "raw_key".to_string(),
            details: format!(
                "Private key must be exactly 32 bytes, got {}",
                secret_bytes.len()
            ),
            source: None,
        });
    }

    let secret_key = secp256k1::SecretKey::from_slice(secret_bytes)
        .map_err(|e| ThresholdError::KeyOperationFailed {
            operation: "parse_private_key".to_string(),
            key_ref: "raw_key".to_string(),
            details: format!("Invalid secp256k1 private key: {}", e),
            source: Some(Box::new(e)),
        })?;

    derive_keypair_from_raw_key(secret_key)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_keypair_from_bytes_valid() {
        // Valid secp256k1 private key (all 1s for testing)
        let secret_bytes = [1u8; 32];
        let keypair = keypair_from_bytes(&secret_bytes).unwrap();

        assert_eq!(keypair.secret_bytes.len(), 32);
        assert_eq!(keypair.public_key.len(), 32); // x-only pubkey
    }

    #[test]
    fn test_keypair_from_bytes_wrong_length() {
        let secret_bytes = [1u8; 31]; // Too short
        let result = keypair_from_bytes(&secret_bytes);

        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("must be exactly 32 bytes"));
    }

    #[test]
    fn test_keypair_from_bytes_invalid_key() {
        // All zeros is invalid secp256k1 key
        let secret_bytes = [0u8; 32];
        let result = keypair_from_bytes(&secret_bytes);

        assert!(result.is_err());
    }

    #[test]
    fn test_derive_keypair_from_raw_key() {
        use secp256k1::SecretKey;

        let secret_key = SecretKey::from_slice(&[1u8; 32]).unwrap();
        let keypair = derive_keypair_from_raw_key(secret_key).unwrap();

        // Verify public key is x-only (32 bytes)
        assert_eq!(keypair.public_key.len(), 32);

        // Verify secret is preserved
        assert_eq!(keypair.secret_bytes, [1u8; 32]);
    }
}
```

---

### Change 3: Update PSKT Signing Logic

**File**: `igra-core/src/application/pskt_signing.rs`

**Find the existing function** (after KeyManager refactor, this will be `sign_pskt_with_key_manager`):

**Replace/Update** the keypair derivation section:

```rust
use crate::foundation::hd::{derive_keypair_from_key_data, keypair_from_bytes};
use crate::infrastructure::config::types::KeyType;
use crate::infrastructure::keys::{KeyManagerContext, KeyRef};

/// Sign PSKT using KeyManager with support for both mnemonic and raw keys
pub async fn sign_pskt_with_key_manager(
    key_context: &KeyManagerContext,
    pskt_json: &str,
    config: &ServiceConfig,
    profile_name: &str,
) -> Result<SignedPskt, ThresholdError> {
    // Parse PSKT
    let pskt: Pskt = serde_json::from_str(pskt_json)
        .map_err(|e| ThresholdError::PsktParseError {
            details: format!("Invalid PSKT JSON: {}", e),
            source: Some(Box::new(e)),
        })?;

    // Get profile configuration
    let profile_config = config.profiles.get(profile_name)
        .ok_or_else(|| ThresholdError::ConfigError {
            details: format!("Profile '{}' not found in configuration", profile_name),
        })?;

    // Derive signing keypair based on key type
    let keypair = match profile_config.key_type {
        KeyType::RawPrivateKey => {
            log::debug!(
                "Loading raw private key for profile '{}' from KeyManager",
                profile_name
            );

            // Construct key reference for raw private key
            let key_ref = KeyRef::new(
                "igra.signer",
                format!("private_key_{}", profile_name),
            );

            // Retrieve secret bytes from KeyManager
            let secret_store = key_context.key_manager()
                .secret_store()
                .ok_or_else(|| ThresholdError::SecretStoreUnavailable {
                    backend: "none".to_string(),
                    details: "KeyManager has no SecretStore available".to_string(),
                    source: None,
                })?;

            let secret_bytes = secret_store
                .get(&key_ref.qualified_name().into())
                .await
                .map_err(|e| {
                    log::error!(
                        "Failed to load raw private key for profile '{}': {}",
                        profile_name,
                        e
                    );
                    e
                })?;

            // Convert raw bytes directly to keypair (no HD derivation)
            keypair_from_bytes(secret_bytes.expose_secret())
                .map_err(|e| {
                    log::error!(
                        "Failed to parse raw private key for profile '{}': {}",
                        profile_name,
                        e
                    );
                    e
                })?
        }

        KeyType::HdMnemonic => {
            log::debug!(
                "Loading HD mnemonic for profile '{}' from KeyManager",
                profile_name
            );

            // Existing HD derivation flow
            let key_ref = KeyRef::new(
                "igra.hd",
                format!("mnemonic_{}", profile_name),
            );

            let secret_store = key_context.key_manager()
                .secret_store()
                .ok_or_else(|| ThresholdError::SecretStoreUnavailable {
                    backend: "none".to_string(),
                    details: "KeyManager has no SecretStore available".to_string(),
                    source: None,
                })?;

            let mnemonic_bytes = secret_store
                .get(&key_ref.qualified_name().into())
                .await?;

            // Convert bytes to mnemonic string
            let mnemonic = String::from_utf8(mnemonic_bytes.expose_secret().to_vec())
                .map_err(|e| ThresholdError::SecretDecodeFailed {
                    name: key_ref.qualified_name(),
                    encoding: "utf8".to_string(),
                    details: format!("Mnemonic is not valid UTF-8: {}", e),
                    source: Some(Box::new(e)),
                })?;

            // Get wallet secret for decryption (if mnemonics are encrypted)
            let wallet_secret_ref = KeyRef::new("igra.hd", "wallet_secret");
            let wallet_secret_bytes = secret_store
                .get(&wallet_secret_ref.qualified_name().into())
                .await?;

            let wallet_secret = String::from_utf8(wallet_secret_bytes.expose_secret().to_vec())
                .map_err(|e| ThresholdError::SecretDecodeFailed {
                    name: wallet_secret_ref.qualified_name(),
                    encoding: "utf8".to_string(),
                    details: format!("Wallet secret is not valid UTF-8: {}", e),
                    source: Some(Box::new(e)),
                })?;

            // Derive keypair using existing HD logic
            derive_keypair_from_key_data(
                &mnemonic,
                &profile_config.derivation_path,
                Some(&wallet_secret),
            )?
        }
    };

    log::info!(
        "Derived signing keypair for profile '{}' using {} (pubkey: {})",
        profile_name,
        profile_config.key_type,
        hex::encode(&keypair.public_key)
    );

    // Sign all PSKT inputs (same logic for both key types)
    let mut partial_signatures = Vec::new();

    for (input_index, input) in pskt.inputs.iter().enumerate() {
        let sighash = compute_sighash(&pskt, input_index)?;
        let signature = sign_schnorr_with_keypair(&keypair, &sighash)?;
        partial_signatures.push(signature);
    }

    Ok(SignedPskt {
        pskt,
        partial_signatures,
        signer_pubkey: keypair.public_key.clone(),
    })
}
```

---

### Change 4: Update devnet-keygen

**File**: `igra-core/src/bin/devnet-keygen.rs`

**Add command-line argument**:

```rust
use clap::Parser;

#[derive(Parser)]
#[command(name = "devnet-keygen")]
#[command(about = "Generate devnet keys and secrets")]
struct Args {
    /// Output format: "env" (shell export), "file" (encrypted), or "both"
    #[arg(short, long, default_value = "both")]
    format: String,

    /// Output file path (for "file" or "both" formats)
    #[arg(short, long, default_value = "./devnet-secrets.bin")]
    output: PathBuf,

    /// Passphrase for encrypted file
    #[arg(short, long)]
    passphrase: Option<String>,

    /// Number of signers to generate
    #[arg(short, long, default_value = "3")]
    num_signers: usize,

    /// Key type: "mnemonic" or "raw"
    #[arg(long, default_value = "mnemonic")]
    key_type: String,
}
```

**Add raw key generation logic**:

```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    println!("ðŸ” Igra Devnet Key Generator");
    println!();

    let mut secrets = HashMap::new();

    // Generate wallet secret (same for both key types)
    let wallet_secret = generate_random_bytes(32);
    secrets.insert(
        SecretName::new("igra.hd.wallet_secret"),
        wallet_secret.clone(),
    );
    println!("âœ“ Generated wallet secret (32 bytes)");

    // Generate payment secret (same for both key types)
    let payment_secret = generate_random_string(16);
    secrets.insert(
        SecretName::new("igra.hd.payment_secret"),
        payment_secret.as_bytes().to_vec(),
    );
    println!("âœ“ Generated payment secret");

    // Generate Iroh seeds (same for both key types)
    let iroh_seed = generate_random_bytes(32);
    secrets.insert(
        SecretName::new("igra.iroh.signer_seed"),
        iroh_seed.clone(),
    );
    println!("âœ“ Generated Iroh signer seed (Ed25519)");

    println!();
    println!("ðŸ“ Generating {} signer keys (type: {}):", args.num_signers, args.key_type);

    // Generate signer keys based on type
    match args.key_type.as_str() {
        "mnemonic" => {
            // Existing mnemonic generation
            for i in 0..args.num_signers {
                let mnemonic = Mnemonic::random(WordCount::Words24, Language::English)?;
                let mnemonic_str = mnemonic.phrase();

                println!("  Signer {}: {} ...", i + 1, &mnemonic_str[..50]);

                // Store mnemonic
                secrets.insert(
                    SecretName::new(format!("igra.hd.mnemonic_signer_{}", i + 1)),
                    mnemonic_str.as_bytes().to_vec(),
                );

                // Derive and display public key
                let xprv = mnemonic.to_extended_key("")?;
                let path = "m/45'/111111'/0'/0/0";
                let derived = xprv.derive_path(path)?;
                let pubkey = derived.public_key();

                println!(
                    "    Pubkey (m/45'/111111'/0'/0/0): {}",
                    hex::encode(pubkey.to_bytes())
                );
            }
        }

        "raw" => {
            // NEW: Raw private key generation
            use secp256k1::{Secp256k1, SecretKey};

            for i in 0..args.num_signers {
                // Generate random 32-byte private key
                let mut secret_bytes = [0u8; 32];
                use rand::RngCore;
                rand::thread_rng().fill_bytes(&mut secret_bytes);

                // Validate it's a valid secp256k1 key
                let secret_key = SecretKey::from_slice(&secret_bytes)
                    .map_err(|e| format!("Failed to generate valid private key: {}", e))?;

                // Store raw private key
                secrets.insert(
                    SecretName::new(format!("igra.signer.private_key_signer_{}", i + 1)),
                    secret_bytes.to_vec(),
                );

                // Derive and display public key
                let secp = Secp256k1::new();
                let pubkey = secp256k1::PublicKey::from_secret_key(&secp, &secret_key);
                let (xonly, _parity) = pubkey.x_only_public_key();

                println!("  Signer {}: raw private key", i + 1);
                println!("    Private key: {}", hex::encode(secret_bytes));
                println!("    X-only pubkey: {}", hex::encode(xonly.serialize()));
            }
        }

        _ => {
            eprintln!("âŒ Invalid key type: {}. Use 'mnemonic' or 'raw'", args.key_type);
            std::process::exit(1);
        }
    }

    println!();

    // Output secrets in requested format (same as before)
    match args.format.as_str() {
        "env" => {
            output_env_format(&secrets)?;
        }
        "file" => {
            let passphrase = args.passphrase.unwrap_or_else(|| {
                prompt_passphrase("Enter passphrase for secrets file: ")
            });
            output_file_format(&secrets, &args.output, &passphrase)?;
        }
        "both" => {
            output_env_format(&secrets)?;
            println!();
            let passphrase = args.passphrase.unwrap_or_else(|| {
                prompt_passphrase("Enter passphrase for secrets file: ")
            });
            output_file_format(&secrets, &args.output, &passphrase)?;
        }
        _ => {
            eprintln!("Invalid format: {}. Use 'env', 'file', or 'both'", args.format);
            std::process::exit(1);
        }
    }

    println!();
    println!("âœ… Done!");

    Ok(())
}
```

---

### Change 5: Add Configuration Validation

**File**: `igra-core/src/infrastructure/config/loader.rs`

**Add validation function** (add to existing validation logic):

```rust
use crate::infrastructure::config::types::{KeyType, ProfileConfig};

/// Validate profile key configuration
fn validate_profile_key_config(profile: &ProfileConfig) -> Result<(), ThresholdError> {
    match profile.key_type {
        KeyType::HdMnemonic => {
            // HD mnemonic requires derivation path
            if profile.derivation_path.is_empty() {
                return Err(ThresholdError::ConfigError {
                    details: format!(
                        "Profile '{}' uses HD mnemonic but has empty derivation_path",
                        profile.name
                    ),
                });
            }

            // Validate derivation path format (basic check)
            if !profile.derivation_path.starts_with("m/") {
                return Err(ThresholdError::ConfigError {
                    details: format!(
                        "Profile '{}' has invalid derivation path '{}' (must start with 'm/')",
                        profile.name,
                        profile.derivation_path
                    ),
                });
            }

            log::debug!(
                "Profile '{}' validated: key_type=hd_mnemonic, path={}",
                profile.name,
                profile.derivation_path
            );
        }

        KeyType::RawPrivateKey => {
            // Raw key should not have derivation path
            if !profile.derivation_path.is_empty() {
                log::warn!(
                    "Profile '{}' uses raw private key but has derivation_path set (will be ignored)",
                    profile.name
                );
            }

            log::debug!(
                "Profile '{}' validated: key_type=raw_private_key",
                profile.name
            );
        }
    }

    Ok(())
}

// Add to existing config validation in load_config()
pub fn load_config(path: &Path) -> Result<ServiceConfig, ThresholdError> {
    // ... existing loading code ...

    // Validate all profiles
    for (profile_name, profile_config) in &config.profiles {
        validate_profile_key_config(profile_config)?;
    }

    Ok(config)
}
```

---

## Testing Strategy

### Unit Tests

#### Test 1: KeyType Parsing

**File**: `igra-core/tests/unit/config_key_type.rs` (new file)

```rust
use igra_core::infrastructure::config::types::KeyType;

#[test]
fn test_key_type_default() {
    let key_type = KeyType::default();
    assert_eq!(key_type, KeyType::HdMnemonic);
}

#[test]
fn test_key_type_display() {
    assert_eq!(KeyType::HdMnemonic.to_string(), "hd_mnemonic");
    assert_eq!(KeyType::RawPrivateKey.to_string(), "raw_private_key");
}

#[test]
fn test_key_type_serde() {
    // Test serialization
    let mnemonic_json = serde_json::to_string(&KeyType::HdMnemonic).unwrap();
    assert_eq!(mnemonic_json, r#""hd_mnemonic""#);

    let raw_json = serde_json::to_string(&KeyType::RawPrivateKey).unwrap();
    assert_eq!(raw_json, r#""raw_private_key""#);

    // Test deserialization
    let parsed: KeyType = serde_json::from_str(r#""hd_mnemonic""#).unwrap();
    assert_eq!(parsed, KeyType::HdMnemonic);

    let parsed: KeyType = serde_json::from_str(r#""raw_private_key""#).unwrap();
    assert_eq!(parsed, KeyType::RawPrivateKey);

    // Test aliases
    let parsed: KeyType = serde_json::from_str(r#""mnemonic""#).unwrap();
    assert_eq!(parsed, KeyType::HdMnemonic);

    let parsed: KeyType = serde_json::from_str(r#""raw""#).unwrap();
    assert_eq!(parsed, KeyType::RawPrivateKey);
}
```

#### Test 2: Raw Key Parsing

**File**: `igra-core/tests/unit/foundation_hd.rs` (add to existing)

```rust
use igra_core::foundation::hd::{keypair_from_bytes, derive_keypair_from_raw_key};

#[test]
fn test_keypair_from_bytes_valid() {
    // Valid secp256k1 private key
    let secret_bytes = [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
        0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
    ];

    let keypair = keypair_from_bytes(&secret_bytes).unwrap();

    // Verify structure
    assert_eq!(keypair.secret_bytes.len(), 32);
    assert_eq!(keypair.public_key.len(), 32); // x-only pubkey
    assert_eq!(keypair.secret_bytes, secret_bytes);
}

#[test]
fn test_keypair_from_bytes_invalid_length() {
    // Too short
    let result = keypair_from_bytes(&[1u8; 31]);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("exactly 32 bytes"));

    // Too long
    let result = keypair_from_bytes(&[1u8; 33]);
    assert!(result.is_err());
}

#[test]
fn test_keypair_from_bytes_invalid_key() {
    // All zeros is invalid
    let result = keypair_from_bytes(&[0u8; 32]);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Invalid secp256k1"));

    // All 0xFF is out of range
    let result = keypair_from_bytes(&[0xFFu8; 32]);
    assert!(result.is_err());
}

#[test]
fn test_derive_keypair_from_raw_key() {
    use secp256k1::SecretKey;

    let secret_key = SecretKey::from_slice(&[0x42u8; 32]).unwrap();
    let keypair = derive_keypair_from_raw_key(secret_key).unwrap();

    // Verify keypair structure
    assert_eq!(keypair.secret_bytes.len(), 32);
    assert_eq!(keypair.public_key.len(), 32);

    // Verify deterministic derivation
    let keypair2 = derive_keypair_from_raw_key(
        SecretKey::from_slice(&[0x42u8; 32]).unwrap()
    ).unwrap();
    assert_eq!(keypair.public_key, keypair2.public_key);
}

#[test]
fn test_keypair_from_hex() {
    let hex_key = "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20";
    let bytes = hex::decode(hex_key).unwrap();

    let keypair = keypair_from_bytes(&bytes).unwrap();

    // Public key should be deterministic
    let expected_pubkey = "9c0257114eb9399a2985f8e75629b5a98ad0e5ee05a8e9f6e0d7e2c3b9e1e2d0";
    assert_eq!(hex::encode(&keypair.public_key), expected_pubkey);
}
```

### Integration Tests

#### Test 3: PSKT Signing with Raw Keys

**File**: `igra-core/tests/integration/pskt_signing_raw_key.rs` (new file)

```rust
use igra_core::application::pskt_signing::sign_pskt_with_key_manager;
use igra_core::infrastructure::config::types::{KeyType, ProfileConfig, ServiceConfig};
use igra_core::infrastructure::keys::{
    EnvSecretStore, LocalKeyManager, NoopAuditLogger, KeyManagerContext,
    SecretName, SecretBytes,
};
use std::sync::Arc;

#[tokio::test]
async fn test_sign_pskt_with_raw_private_key() {
    // Set up raw private key in environment
    let private_key_hex = "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20";
    std::env::set_var(
        "IGRA_SECRET__igra_signer__private_key_signer_1",
        format!("hex:{}", private_key_hex)
    );

    // Create KeyManager
    let secret_store = Arc::new(EnvSecretStore::new());
    let audit_log = Arc::new(NoopAuditLogger);
    let key_manager = Arc::new(LocalKeyManager::new(secret_store, audit_log.clone()));
    let key_context = KeyManagerContext::with_new_request_id(key_manager, audit_log);

    // Create minimal config
    let mut config = ServiceConfig::default();
    let mut profile = ProfileConfig::default();
    profile.name = "signer-1".to_string();
    profile.key_type = KeyType::RawPrivateKey;
    profile.derivation_path = "".to_string();
    config.profiles.insert("signer-1".to_string(), profile);

    // Create test PSKT
    let pskt_json = r#"{
        "version": 0,
        "inputs": [{
            "previous_outpoint": {
                "transaction_id": "0000000000000000000000000000000000000000000000000000000000000000",
                "index": 0
            },
            "sequence": 0,
            "sig_op_count": 1
        }],
        "outputs": [{
            "value": 100000000,
            "script_public_key": "76a914..."
        }]
    }"#;

    // Sign PSKT
    let result = sign_pskt_with_key_manager(
        &key_context,
        pskt_json,
        &config,
        "signer-1",
    ).await;

    assert!(result.is_ok(), "PSKT signing should succeed");
    let signed = result.unwrap();

    // Verify signature was generated
    assert!(!signed.partial_signatures.is_empty());
    assert_eq!(signed.signer_pubkey.len(), 32); // x-only pubkey
}

#[tokio::test]
async fn test_sign_pskt_with_mnemonic_vs_raw_key_same_config() {
    // Test that both key types can coexist in same config

    // Set up secrets
    std::env::set_var(
        "IGRA_SECRET__igra_signer__private_key_signer_1",
        "hex:0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20"
    );
    std::env::set_var(
        "IGRA_SECRET__igra_hd__mnemonic_signer_2",
        "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
    );
    std::env::set_var(
        "IGRA_SECRET__igra_hd__wallet_secret",
        "test_secret"
    );

    // Create KeyManager
    let secret_store = Arc::new(EnvSecretStore::new());
    let audit_log = Arc::new(NoopAuditLogger);
    let key_manager = Arc::new(LocalKeyManager::new(secret_store, audit_log.clone()));
    let key_context = KeyManagerContext::with_new_request_id(key_manager, audit_log);

    // Create config with both types
    let mut config = ServiceConfig::default();

    let mut profile1 = ProfileConfig::default();
    profile1.name = "signer-1".to_string();
    profile1.key_type = KeyType::RawPrivateKey;

    let mut profile2 = ProfileConfig::default();
    profile2.name = "signer-2".to_string();
    profile2.key_type = KeyType::HdMnemonic;
    profile2.derivation_path = "m/45'/111111'/0'/0/0".to_string();

    config.profiles.insert("signer-1".to_string(), profile1);
    config.profiles.insert("signer-2".to_string(), profile2);

    // Both should work
    let pskt_json = create_test_pskt_json();

    let result1 = sign_pskt_with_key_manager(&key_context, pskt_json, &config, "signer-1").await;
    let result2 = sign_pskt_with_key_manager(&key_context, pskt_json, &config, "signer-2").await;

    assert!(result1.is_ok());
    assert!(result2.is_ok());
}
```

#### Test 4: Configuration Validation

**File**: `igra-core/tests/integration/config_validation_key_type.rs` (new file)

```rust
use igra_core::infrastructure::config::loader::load_config;
use std::path::PathBuf;
use tempfile::TempDir;

#[test]
fn test_config_hd_mnemonic_requires_derivation_path() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");

    // Config with HD mnemonic but no derivation path (invalid)
    std::fs::write(&config_path, r#"
[profiles.signer-1]
name = "signer-1"
key_type = "hd_mnemonic"
derivation_path = ""
rpc_address = "127.0.0.1:8088"
    "#).unwrap();

    let result = load_config(&config_path);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("empty derivation_path"));
}

#[test]
fn test_config_raw_key_ignores_derivation_path() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");

    // Config with raw key and derivation path (valid, but warns)
    std::fs::write(&config_path, r#"
[profiles.signer-1]
name = "signer-1"
key_type = "raw_private_key"
derivation_path = "m/45'/111111'/0'/0/0"
rpc_address = "127.0.0.1:8088"
    "#).unwrap();

    let result = load_config(&config_path);
    // Should load successfully (logs warning)
    assert!(result.is_ok());
}

#[test]
fn test_config_default_key_type() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");

    // Config without key_type specified (should default to HdMnemonic)
    std::fs::write(&config_path, r#"
[profiles.signer-1]
name = "signer-1"
derivation_path = "m/45'/111111'/0'/0/0"
rpc_address = "127.0.0.1:8088"
    "#).unwrap();

    let result = load_config(&config_path);
    assert!(result.is_ok());

    let config = result.unwrap();
    let profile = config.profiles.get("signer-1").unwrap();
    assert_eq!(profile.key_type, KeyType::HdMnemonic);
}
```

### End-to-End Test

#### Test 5: Full Signing Flow

**File**: `igra-service/tests/integration/e2e_raw_key_signing.rs` (new file)

```rust
/// End-to-end test: Generate raw key, sign PSKT, verify signature
#[tokio::test]
async fn test_e2e_raw_key_workflow() {
    use secp256k1::{Secp256k1, SecretKey, Message};
    use sha2::{Sha256, Digest};

    // 1. Generate raw private key
    let secret_key = SecretKey::from_slice(&[0x42u8; 32]).unwrap();
    let secret_hex = hex::encode(secret_key.secret_bytes());

    // 2. Set up environment
    std::env::set_var(
        "IGRA_SECRET__igra_signer__private_key_test",
        format!("hex:{}", secret_hex)
    );

    // 3. Create KeyManager
    let secret_store = Arc::new(EnvSecretStore::new());
    let audit_log = Arc::new(NoopAuditLogger);
    let key_manager = Arc::new(LocalKeyManager::new(secret_store, audit_log.clone()));

    // 4. Sign a message using KeyManager
    let key_ref = KeyRef::new("igra.signer", "private_key_test");
    let message = b"test message";

    let signature = key_manager.sign(
        &key_ref,
        SignatureScheme::Secp256k1Schnorr,
        SigningPayload::Message(message),
    ).await.unwrap();

    // 5. Verify signature
    assert_eq!(signature.len(), 64); // Schnorr signature is 64 bytes

    // 6. Verify with secp256k1 library
    let secp = Secp256k1::new();
    let pubkey = secp256k1::PublicKey::from_secret_key(&secp, &secret_key);
    let (xonly, _) = pubkey.x_only_public_key();

    // Hash message
    let mut hasher = Sha256::new();
    hasher.update(message);
    let hash = hasher.finalize();

    // Verify signature
    let msg = Message::from_slice(&hash).unwrap();
    let sig = secp256k1::schnorr::Signature::from_slice(&signature).unwrap();

    assert!(secp.verify_schnorr(&sig, &msg, &xonly).is_ok());
}
```

---

## Migration Guide

### Scenario 1: New Deployment with Raw Keys

**Use Case**: Setting up fresh Igra deployment with raw private keys

**Steps**:

1. **Generate raw private keys**:
   ```bash
   cargo run --bin devnet-keygen -- \
     --format file \
     --key-type raw \
     --num-signers 3 \
     --output ./secrets.bin \
     --passphrase "<strong-passphrase>"
   ```

2. **Update configuration**:
   ```toml
   # igra-config.toml
   [profiles.signer-1]
   name = "signer-1"
   key_type = "raw_private_key"
   derivation_path = ""  # Not used
   rpc_address = "127.0.0.1:8088"

   [profiles.signer-2]
   name = "signer-2"
   key_type = "raw_private_key"
   derivation_path = ""
   rpc_address = "127.0.0.1:8089"

   [profiles.signer-3]
   name = "signer-3"
   key_type = "raw_private_key"
   derivation_path = ""
   rpc_address = "127.0.0.1:8090"
   ```

3. **Start service**:
   ```bash
   export IGRA_SECRETS_PASSPHRASE="<strong-passphrase>"
   cargo run --bin kaspa-threshold-service -- \
     --config ./igra-config.toml \
     --data-dir ./data
   ```

### Scenario 2: Migrate Existing Mnemonic to Raw Key

**Use Case**: You have an existing mnemonic and want to extract the private key

**Steps**:

1. **Extract private key from mnemonic**:
   ```rust
   // One-time migration script
   use kaspa_bip32::Mnemonic;

   let mnemonic = Mnemonic::from_phrase("word1 word2 ... word24")?;
   let xprv = mnemonic.to_extended_key("")?;
   let derived = xprv.derive_path("m/45'/111111'/0'/0/0")?;
   let private_key = derived.private_key();

   println!("Private key: {}", hex::encode(private_key.to_bytes()));
   ```

2. **Store extracted private key in KeyManager**:
   ```bash
   # Add to secrets.bin or set as env var
   export IGRA_SECRET__igra_signer__private_key_signer_1="hex:deadbeef..."
   ```

3. **Update configuration**:
   ```toml
   [profiles.signer-1]
   key_type = "raw_private_key"  # Changed from hd_mnemonic
   derivation_path = ""            # Remove derivation path
   ```

### Scenario 3: Mixed Deployment

**Use Case**: Use mnemonics for some signers, raw keys for others

**Configuration**:
```toml
# Signer 1: Raw key (from hardware wallet)
[profiles.signer-1]
name = "signer-1"
key_type = "raw_private_key"
derivation_path = ""
rpc_address = "127.0.0.1:8088"

# Signer 2: HD mnemonic (standard setup)
[profiles.signer-2]
name = "signer-2"
key_type = "hd_mnemonic"
derivation_path = "m/45'/111111'/0'/0/0"
rpc_address = "127.0.0.1:8089"

# Signer 3: HD mnemonic with different index
[profiles.signer-3]
name = "signer-3"
key_type = "hd_mnemonic"
derivation_path = "m/45'/111111'/0'/0/1"
rpc_address = "127.0.0.1:8090"
```

**Secrets in KeyManager**:
```
igra.signer.private_key_signer_1 = [32 bytes]  # Raw key
igra.hd.mnemonic_signer_2 = "word1 word2 ..."  # Mnemonic
igra.hd.mnemonic_signer_3 = "word1 word2 ..."  # Mnemonic
```

### Scenario 4: Devnet with Raw Keys

**Update devnet scripts**:

```bash
# In run_local_devnet.sh, add key-type option:
./devnet-keygen --key-type raw  # Generate raw keys instead of mnemonics

# Then start as normal:
./run_local_devnet.sh default
```

---

## Validation Checklist

### Code Completion

- [ ] `KeyType` enum added to `config/types.rs`
- [ ] `keypair_from_bytes()` added to `foundation/hd.rs`
- [ ] `derive_keypair_from_raw_key()` added to `foundation/hd.rs`
- [ ] `sign_pskt_with_key_manager()` updated for key type dispatch
- [ ] `devnet-keygen` supports `--key-type raw` flag
- [ ] Configuration validation checks key type consistency
- [ ] All code compiles without warnings

### Testing

- [ ] Unit tests pass for `KeyType` serde
- [ ] Unit tests pass for `keypair_from_bytes()`
- [ ] Unit tests pass for invalid key detection
- [ ] Integration test: PSKT signing with raw key
- [ ] Integration test: Mixed config (mnemonic + raw key)
- [ ] Integration test: Config validation
- [ ] End-to-end test: Full signing workflow
- [ ] Performance benchmark: raw key vs mnemonic

### Documentation

- [ ] Code comments on all new functions
- [ ] Examples added to `keypair_from_bytes()` docstring
- [ ] Config TOML examples updated
- [ ] Migration scenarios documented
- [ ] Team training completed

### Backwards Compatibility

- [ ] Existing mnemonic-based configs load successfully
- [ ] Default `key_type` is `hd_mnemonic`
- [ ] All existing tests still pass
- [ ] Devnet scripts work with both key types
- [ ] No breaking changes to APIs

### Security

- [ ] Raw keys zeroized after use
- [ ] No raw keys logged
- [ ] Audit log captures key type used
- [ ] Invalid keys rejected with clear errors
- [ ] File permissions enforced on secrets.bin

---

## Performance Benchmark

**Script**: `igra-core/benches/raw_key_vs_mnemonic.rs`

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use igra_core::foundation::hd::{derive_keypair_from_key_data, keypair_from_bytes};

fn benchmark_mnemonic_derivation(c: &mut Criterion) {
    let mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
    let derivation_path = "m/45'/111111'/0'/0/0";
    let payment_secret = Some("test");

    c.bench_function("derive_keypair_from_mnemonic", |b| {
        b.iter(|| {
            derive_keypair_from_key_data(
                black_box(mnemonic),
                black_box(derivation_path),
                black_box(payment_secret),
            )
        })
    });
}

fn benchmark_raw_key_derivation(c: &mut Criterion) {
    let raw_key = [0x42u8; 32];

    c.bench_function("keypair_from_bytes", |b| {
        b.iter(|| {
            keypair_from_bytes(black_box(&raw_key))
        })
    });
}

criterion_group!(benches, benchmark_mnemonic_derivation, benchmark_raw_key_derivation);
criterion_main!(benches);
```

**Expected Results**:
- Mnemonic derivation: ~1-2ms
- Raw key derivation: ~50-100Î¼s
- **Speedup: ~10-20x faster** for raw keys

---

## Rollout Plan

### Week 1: Implementation

**Day 1-2**: Core changes
- [ ] Implement `KeyType` enum
- [ ] Add `keypair_from_bytes()` helpers
- [ ] Write unit tests

**Day 3-4**: Integration
- [ ] Update PSKT signing logic
- [ ] Update devnet-keygen
- [ ] Write integration tests

**Day 5**: Documentation
- [ ] Update code comments
- [ ] Create examples
- [ ] Write migration guide

### Week 2: Testing & Validation

**Day 1-2**: Testing
- [ ] Run full test suite
- [ ] Performance benchmarking
- [ ] Security review

**Day 3-4**: Team validation
- [ ] Team testing in devnet
- [ ] Review migration scenarios
- [ ] Update operator docs

**Day 5**: Release
- [ ] Merge to devel
- [ ] Tag release
- [ ] Announce feature

---

## FAQ

### Q: Can I mix mnemonic and raw keys in the same multisig?

**A**: Yes! Each signer can independently choose their key type. The multisig address is computed from the public keys, which are the same regardless of whether they come from a mnemonic or raw key.

### Q: What if I want to migrate from mnemonic to raw key later?

**A**: Extract the private key from your mnemonic at the specific derivation path, store it as a raw key in KeyManager, and update your config to `key_type = "raw_private_key"`. The public key remains the same, so your multisig address doesn't change.

### Q: Are raw keys less secure than mnemonics?

**A**: No, they're equally secure. Mnemonics are just a human-friendly encoding of entropy. The actual private key is the same size (32 bytes). Both should be stored encrypted in `secrets.bin`.

### Q: Can I use a raw key from a hardware wallet?

**A**: Yes! Export the private key from your hardware wallet (if supported), store it in KeyManager as a raw key, and configure the profile with `key_type = "raw_private_key"`.

### Q: Does this work with the existing KeyManager refactor?

**A**: Yes, this feature builds on top of the KeyManager refactor. Implement KeyManager first (Phase 1), then add this feature (Phase 1.5).

### Q: What about key rotation?

**A**: Key rotation works the same for both types. You can rotate from mnemonic to raw key or vice versa by changing the `key_type` and updating the secret in KeyManager.

---

## Success Criteria

Feature is complete when:

1. âœ… All tests pass (unit, integration, e2e)
2. âœ… Both key types work in devnet
3. âœ… Mixed deployments (mnemonic + raw) work
4. âœ… Performance improvement measured (>10x for raw keys)
5. âœ… Documentation complete
6. âœ… Team can use feature without confusion
7. âœ… Zero breaking changes to existing configs

---

## Support

If you encounter issues during implementation:

1. Check error messages - they include key type information
2. Verify config has correct `key_type` field
3. Ensure raw keys are exactly 32 bytes
4. Check audit logs for key loading details
5. Test with `--key-type raw` flag in devnet-keygen

**Common issues**:

- "Invalid secp256k1 private key": Key bytes are out of range or invalid
- "Empty derivation_path": Using `hd_mnemonic` without derivation path
- "Secret not found": Key reference doesn't match stored secret name

---

END OF GUIDE
